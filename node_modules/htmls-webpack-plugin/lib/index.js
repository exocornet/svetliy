"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pathLib = require("path");
const fs = require("fs");
const ejs = require("ejs");
function isCustomParamsFn(g) {
    return typeof g === 'function';
}
function defaults(val, defaults) {
    return val == null ? defaults : val;
}
class HtmlsPlugin {
    constructor(props) {
        this.props = props;
    }
    apply(compiler) {
        const logger = compiler.getInfrastructureLogger(HtmlsPlugin.name);
        let outputPath = compiler.options.output.path || process.cwd();
        let publicPath = this.props.publicPath || compiler.options.output.publicPath || '';
        let defaultRender = (src, params) => {
            return ejs.renderFile(src, params, { async: true });
        };
        let toCDN = (f) => {
            if (typeof publicPath === 'function') {
                publicPath = publicPath(f);
            }
            return publicPath + f;
        };
        compiler.hooks.thisCompilation.tap(HtmlsPlugin.name, (compilation) => {
            const { sources, Compilation } = require('webpack');
            compilation.hooks.processAssets.tapPromise({
                name: this.constructor.name,
                // https://github.com/webpack/webpack/blob/master/lib/Compilation.js#L3280
                stage: Compilation.PROCESS_ASSETS_STAGE_REPORT,
            }, async () => {
                if (this.props.beforeEmit) {
                    await this.props.beforeEmit(compilation, compiler);
                }
                let assets = { ...compilation.assets };
                let files = Object.keys(assets).map(toCDN);
                let jses = files.filter((k) => k.endsWith('.js')).reverse();
                let csses = files.filter((k) => k.endsWith('.css'));
                let entries = [];
                for (const [k, v] of compilation.entrypoints) {
                    entries = entries.concat(v.getFiles());
                }
                entries = entries.map(toCDN);
                logger.log('Start building htmls');
                logger.time('builded-htmls');
                async function resolveCustomParams(params) {
                    return isCustomParamsFn(params)
                        ? await params(compilation, compiler)
                        : params;
                }
                const propCustomParams = await resolveCustomParams(this.props.params);
                await Promise.all(this.props.htmls.map(async (html) => {
                    let src = pathLib.resolve(process.cwd(), html.src);
                    let render = html.render || this.props.render || defaultRender;
                    let htmlCustomParams = await resolveCustomParams(html.params);
                    let params = {
                        files: files.slice(),
                        jses: jses.slice(),
                        csses: csses.slice(),
                        entries: entries.slice(),
                        options: this.props,
                        compilation,
                        ...propCustomParams,
                        ...htmlCustomParams,
                    };
                    let transform = this.props.transformParams || html.transformParams;
                    if (transform) {
                        params = transform(params);
                    }
                    let source = await render(src, params);
                    let filename = typeof html.filename === 'string'
                        ? html.filename
                        : html.filename(source, src, params);
                    let flushOnDev = defaults(defaults(this.props.flushOnDev, html.flushOnDev), false);
                    if (flushOnDev) {
                        let outFile = typeof flushOnDev === 'string'
                            ? flushOnDev
                            : pathLib.resolve(outputPath, filename);
                        fs.writeFile(outFile, source, (err) => {
                            if (err)
                                console.error(err);
                        });
                    }
                    compilation.emitAsset(filename, new sources.RawSource(source));
                }));
                logger.timeEnd('builded-htmls');
                if (this.props.afterEmit) {
                    await this.props.afterEmit(compilation, compiler);
                }
            });
        });
    }
}
exports.default = HtmlsPlugin;
module.exports = HtmlsPlugin;
module.exports.default = HtmlsPlugin;
//# sourceMappingURL=index.js.map